[{"title":"表格数据的展示和下载","url":"/2022/05/05/export-to-excel/","content":"\n## 前言\n\n某管控后台需要进行生产数据的展示和报表，此前都是又管理人员进行统计计算。对生产采数数据筛选，并展示到网页端，提供下载导出功能。\n\n## 正文\n\n需求核心问题点是需要显示表格模板上的格式，且后端获取数据进行统计筛选需要的时间过长。\n\n### table组件\n原本是想按照用常规的table组件然后拆分每个表格单独展示，但这种方式无法很好的展示表格中的合并单元格，样式会很奇怪后面决定寻找其他方案。\n\n### officeapps\n通过微软的web在线办公工具展示\n","tags":["vue"],"categories":["frontend"]},{"title":"设计模式（二） 工厂方法模式","url":"/2021/05/20/Design-Pattern-Factory-Method/","content":"\n## 正文\n\n```typescript\ninterface Pizza {\n    Prepare: ()=> String,\n    Bake: ()=> String,\n    Cut: () => String,\n    Box: () => String \n}\nabstract class Pizza(){\n    abstract Prepare():String;\n    abstract Bake():String;\n    abstract Cut():String;\n    abstract Box():String;\n}\nclass PizzaStore() {\n    let name;\n    OrderPizza: function(){\n        switch(type)\n    }\n}\n```\n","categories":["frontend"]},{"title":"解决图像检测demo的超时问题","url":"/2021/05/19/photocheck-timeout/","content":"\n## 前言\n图像检测的demo在测试时出现了在并发上去后出现`504 Gateway Time-out. The gateway did not receive a timely response from the upstream server or application.`的问题，导致识别失败，记录排查过程。\n\n## 过程\n\n在部署了一个测试服务器后，安装相同版本的环境时出现新的问题。python执行命令时出现`ImportError: DLL load failed`找不到指定模块，刚开始以为是缺少dll文件，想查询缺少的文件进行补充，后面发现没办法补足。进一步查找方案时发现是pip下载包时需要在管理员模式下进行。\n\n环境解决以后问题复现不出来，查询Apache的错误日志，有查到一条`AH00326: Server ran out of threads to serve requests. Consider raising the ThreadsPerChild setting`的记录，于是在`httpd-mpm.conf`中提升了子线程的数量，但依然有超时问题。\n\n```\n<IfModule mpm_winnt_module>\nThreadsPerChild 512 \nMaxRequestsPerChild 0\n</IfModule>\n```\n\n查询了Apache的访问日志，发现返回的状态码都是正常的，应该是请求被拦截了。Remote Address也不是服务器的地址。\n![headers](/images/202105/20210519105659.png)\n\n应该是阿里云cdn回源请求那边超时时间的设置问题\n\n![回源请求超时时间](/images/202105/20210519112320.png)\n\n最后通过ip地址访问接口，绕开域名绑定的cdn回源方式解决这个问题\n\n## 补充\n\n如果是服务器问题的一些配置。\n\nnginx访问出现504 Gateway Time-out，一般是由于程序执行时间过长导致响应超时，例如程序需要执行90秒，而nginx最大响应等待时间为30秒，这样就会出现超时。通常有以下几种情况导致\n\n1.程序在处理大量数据，导致等待超时。\n2.程序中调用外部请求，而外部请求响应超时。\n3.连接数据库失败而没有停止，死循环重新连。\n\n解决方法参考这篇[文章](https://blog.csdn.net/haibo0668/article/details/103869582/)\n","categories":["frontend"]},{"title":"使用pm2维护Laravel队列","url":"/2021/05/11/pm2-artisan-queue/","content":"\n## 前言\n\n当前维护着的CTC效能平台项目需要升级，把几个子程序规整到一个平台上进行管理。以`web管理平台->PHP后端->C++数据层->子程序`形式组成，php后端与C++数据层中的通信才用socket协议。php的短生命周期，目前使用Laravel框架且不使用swoole的情况下采用框架内队列（queue）。队列进程是长生命周期的进程，socket获取C++提供的最新数据。\n\n## 问题\n\n但出现几种问题需要解决\n\n- artisan命令是放在bat批处理文件内执行的，出错中止无法维护\n- php的socket_read()每次执行占用了较大的内存并且没有释放，导致内存溢出\n\n## 解决方案\n\nLaravel文档内的方案是使用Supervisor进行进程守护，但由于服务器是window系统，所以决定用pm2。\n\n先全局安装pm2\n```bash\nnpm i pm2 -g \n```\n\n安装pm2的windows服务，之后就可以在windows服务内多出一个pm2服务\n```bash\nnpm i pm2-windows-service -g\npm2-service-install -n pm2\n```\n\n\n接下来需要配置需要执行的命令，参考这篇[文章](https://subashbasnet.com.np/how-to-run-and-monitor-laravel-queue-using-pm2/)\n\n```yaml\n#laravel-queue-worker.yml\napps:\n  - name: laravel-queue-worker\n    script: artisan\n    exec_mode: fork\n    interpreter: php\n    instances: 1\n    args:\n      - queue:work\n      - --tries=5\n      - --sleep=1\n      - --delay=3\n\n```\n\n内存泄漏的问题原计划是用设置jobs执行数量上限，退出后由pm2重启。但需要Laravel8才能支持，Laravel8还需要php7.3以上的版本支持，升级成本较高。\n","tags":["pm2","php","Laravel"],"categories":["backend"]},{"title":"设计模式（一） 策略模式","url":"/2021/04/28/Design-Pattern-Strategy/","content":"\n## 前言\n\n一直以来对设计模式很是头疼，在当初PHP提升路上学习了几次但依然难以运用之后容易遗忘。虽然平常开发过程中总是会注意一些架构的合理性，方便后续的扩展，但没有理论的支撑实施起来的方案还是问题很多。刚好最近团队在设计模式上一起学习提升，记录学习笔记并归纳在JavaScript和TypeScript中的运用。接下来，首先从策略模式开始\n\n## 正文\n\n先从一个需求出发吧，如果在我的空间发言，需要满足几个条件才能发送\n\n- 普通用户\n- 是否通过实名认证\n- 等级大于10\n- 发言数大于100\n\n从以往来看，大多都会使用`if else`来条件判断是否符合发言条件\n\n```Javascript\nfunction checkCondition(data) {\n  if (data.role !== 'user') {\n    console.log('不是普通用户');\n    return false;\n  }\n  if (!data.userAuth) {\n    console.log('未通过实名认证');\n    return false;\n  }\n  if (data.level < 10) {\n    console.log('等级不足');\n    return false;\n  }\n  if (data.comment < 100) {\n    console.log('发言数不足');\n    return false;\n  }\n}\n```\n\n初步看好像可行，但实际上出现了这些问题\n\n- 后续条件不断增加下去checkCondition里需要不断增加判断\n- 函数内逻辑过于复杂，违反单一功能原则\n- 条件没法复用\n- 违反开闭原则\n\n为了解决这些问题，我们需要引入策略模式\n\n### 策略模式\n\n定义 : 要实现某一个功能，有多种方案可以选择。我们定义策略，把它们一个个封装起来，并且使它们可以相互转换。\n\n使用策略模式修改后\n\n```Javascript\n// 策略\nvar strategies = {\n  checkRole: function(value) {\n    return value === 'user';\n  },\n  checkAuth: function(value) {\n    return value;\n  },\n  checkLevel: function(value) {\n    return value < 10;\n  },\n  checkComment: function(value) {\n    return value < 100;\n  }\n};\n```\n\n```Javascript\n// 调用\nfunction checkOne(name, value) {\n  return strategies[name](value)\n}\n```\n\n这边我们先通过将条件判断的逻辑拆解出不同方法来，解决单一功能原则和复用的问题。后续为了满足开闭原则利用对象映射的灵活性将条件判断的方法置于strategies对象内。后面在调用时只需要通过方法名和参数就能使用相应方法了。\n\n接着进行优化，添加一个验证器\n\n```Javascript\n// 校验规则\nvar Validator = function() {\n  this.cache = [];\n\n  // 添加策略事件\n  this.add = function(value, method) {\n    this.cache.push(function() {\n      return strategies[method](value);\n    });\n  };\n\n  // 检查\n  this.check = function() {\n    for (let i = 0; i < this.cache.length; i++) {\n      let valiFn = this.cache[i];\n      var data = valiFn(); // 开始检查\n      if (!data) {\n        return false;\n      }\n    }\n    return true;\n  };\n};\n```\n\n设置一个用户进行测试\n\n```Javascript\nvar user = function() {\n  var validator = new Validator();\n  const data = {\n    role: 'user',\n    auth: true,\n    level: 8,\n    comment: 123\n  };\n  validator.add(data.role, 'checkRole');\n  validator.add(data.auth, 'checkAuth');\n  validator.add(data.level, 'checkLevel');\n  validator.add(data.comment, 'checkComment');\n  const result = validator.check();\n  return result;\n};\n\n```\n\n最重要的是学习之后什么时候使用呢？\n\n- 各判断条件下的策略相互独立且可复用\n- 策略内部逻辑相对复杂\n- 策略需要灵活组合\n","tags":["设计模式"],"categories":["frontend"]},{"title":"vue3 VCA","url":"/2021/04/22/vue3-VCA/","content":"## 前言\n\n之前看文章的时候有看到Vue Composition API但没有继续深入，最近看到尤大的回答中提及到了，然而不太熟悉，于是进行了系统的学习和总结。\n\n## 开始\n\nVue Composition API 是 Vue 3.0 的一个重要特性，和 React Hooks 一样，这是一种非常棒的逻辑组合/复用机制。据官方所说React Hooks是VCA的灵感来源，并且基于自己的数据响应式机制创建自己特色的逻辑复用原语。\n","tags":["Vue"],"categories":["frontend"]},{"title":"webpack配置与优化","url":"/2021/04/09/webpack-config/","content":"在以往开发过程中有用到`vue-cli`、`create-react-app`等脚手架构建管理项目，只是在需要的时候查找相关问题。提升道路上还是有必要系统的进行学习和补充。\n\n## 基本的配置\n\n<br>\n\n### 初始化项目\n\n首先创建就目录初始化npm\n`npm init`\n\n下载webpack的两个包\n`npm i -D webpack webpack-cli`\n\n配置package.json\n```\n\"script\":{\n    \"build\":\"webpack src/main.js\"\n}\n```\n\n`npm run build`进行打包，在目录下生成dist文件夹\n\n### 生成自定义配置\n\n现在使用的是默认配置，接下来需要创建可自定义的配置文件。在build文件夹下创建`webpack.config.js`\n\n```\n// webpack.config.js\n\nconst path = require('path');\nmodule.exports = {\n    mode:'development', // 开发模式\n    entry: path.resolve(__dirname,'../src/main.js'),    // 入口文件\n    output: {\n        filename: 'output.js',      // 打包后的文件名称\n        path: path.resolve(__dirname,'../dist')  // 打包后的目录\n    }\n}\n```\n\n设置打包命令使用配置文件\n\n```\n\"script\":{\n    \"build\":\"webpack --config build/webpack.config.js\"\n}\n```\n\n打包之后的dist下的`main.js`就是实际运行的文件\n\n### 配置html模板\n\njs文件打包好之后，还需要在html文件中进行引用。\n>通常在生产模式下考虑资源缓存的问题会在文件名中加入hash串，所以引用也不是固定的。因此可能这样配置\n```\nmodule.exports = {\n    // 省略其他配置\n    output: {\n      filename: '[name].[hash:8].js',      // 打包后的文件名称\n      path: path.resolve(__dirname,'../dist')  // 打包后的目录\n    }\n}\n```\n\n每次的文件名不同，因此需要动态的将js文件引入到html中，使用`html-webpack-plugin`\n\n`npm i -D html-webpack-plugin`\n\n配置文件如下\n```\n// webpack.config.js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n    mode:'development', // 开发模式\n    entry: path.resolve(__dirname,'../src/main.js'),    // 入口文件\n    output: {\n      filename: '[name].[hash:8].js',      // 打包后的文件名称\n      path: path.resolve(__dirname,'../dist')  // 打包后的目录\n    },\n    plugins:[\n      new HtmlWebpackPlugin({\n        template:path.resolve(__dirname,'../public/index.html')\n      })\n    ]\n}\n```\n打包后js文件自动引入到html文件中\n![js引入效果](/images/202104/20210412171823.png)\n\n### 清理残留文件\n每次执行打包命令时之前的打包文件还会继续存在，不符合需要，因此需要在打包前清楚残留。\n`npm i -D clean-webpack-plugin`\n\n配置：\n```\nconst {CleanWebpackPlugin} = require('clean-webpack-plugin')\nmodule.exports = {\n    // ...省略其他配置\n    plugins:[new CleanWebpackPlugin()]\n}\n```\n\n### 引用CSS\n\n除了js资源外也需要引入css文件，需要使用一些loader来解析css文件\n`npm i -D style-loader css-loader`\n\n如果要使用less、scss等预处理语言，需要额外的loader进行解析，这里我们使用less\n`npm i -D less less-loader`\n\n配置：\n```\n// webpack.config.js\nmodule.exports = {\n    // ...省略其他配置\n    module:{\n      rules:[\n        {\n          test:/\\.css$/,\n          use:['style-loader','css-loader'] // 从右向左解析原则\n        },\n        {\n          test:/\\.less$/,\n          use:['style-loader','css-loader','less-loader'] // 从右向左解析原则\n        }\n      ]\n    }\n}\n```\n\n#### 添加css前缀\n\n`npm i -D postcss-loader autoprefixer`\n\n配置如下：\n```\n// webpack.config.js\nmodule.exports = {\n    module:{\n        rules:[\n            {\n                test:/\\.less$/,\n                use:['style-loader','css-loader','postcss-loader','less-loader'] // 从右向左解析原则\n           }\n        ]\n    }\n} \n```\n\n有两种方式引入`autoprefixer`\n1.在项目根目录下创建一个`postcss.config.js`文件，配置如下：\n```\nmodule.exports = {\n    plugins: [require('autoprefixer')]  // 引用该插件即可了\n}\n```\n\n2.直接在`webpack.config.js`里配置\n```\n// webpack.config.js\nmodule.exports = {\n    module:{\n        rules:[{\n            test:/\\.less$/,\n            use:['style-loader','css-loader',{\n                loader:'postcss-loader',\n                options:{\n                    plugins:[require('autoprefixer')]\n                }\n            },'less-loader'] // 从右向左解析原则\n        }]\n    }\n}\n```\n\n#### 拆分css\n使用`mini-css-extract-plugin`插件把css从js文件中提取出来\n\n`npm i -D mini-css-extract-plugin`\n\n配置如下：\n```\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        use: [\n           MiniCssExtractPlugin.loader,\n          'css-loader',\n          'less-loader'\n        ],\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n        filename: \"[name].[hash].css\",\n        chunkFilename: \"[id].css\",\n    })\n  ]\n}\n```\n\n### 引入图片、字体、视频等文件\n`file-loader`的主要功能是处理文件名，例如文件名中添加hash值，解析文件路径，并将文件移动到输出的目录中\n`url-loader` 一般与file-loader搭配使用，功能与 `file-loader` 类似，可以设置一定的文件大小内返回 base64 编码进行优化，否则使用 `file-loader` 将文件移动到输出的目录中\n\n```\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      // ...\n      {\n        test: /\\.(jpe?g|png|gif)$/i, //图片文件\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10240,\n              fallback: {\n                loader: 'file-loader',\n                options: {\n                    name: 'img/[name].[hash:8].[ext]'\n                }\n              }\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, //媒体文件\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10240,\n              fallback: {\n                loader: 'file-loader',\n                options: {\n                  name: 'media/[name].[hash:8].[ext]'\n                }\n              }\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/i, // 字体\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10240,\n              fallback: {\n                loader: 'file-loader',\n                options: {\n                  name: 'fonts/[name].[hash:8].[ext]'\n                }\n              }\n            }\n          }\n        ]\n      },\n    ]\n  }\n}\n```\n\n### babel转义\n\n`npm i -D babel-loader @babel/preset-env @babel/core`\n上面的`babel-loader`默认只会将ES6/ES7/ES8的语法进行转义，一些api无法进行转换，例如Promise、Maps、Set\n因此还需要增加polyfill转换\n`npm i @babel/polyfill`\n配置如下\n```\n// webpack.config.js\nconst path = require('path')\nmodule.exports = {\n    entry: [\"@babel/polyfill\",path.resolve(__dirname,'../src/index.js')],    // 入口文件\n}\n```\n","tags":["webpack"],"categories":["frontend"]},{"title":"webAR —— AR.js demo","url":"/2021/03/06/webAR/","content":"\n## 前言\n\n最近有个新的调研需求，需要做到使用手机摄像扫在产品上的包装，实现一个展开的动画模型效果。初步的讨论后还是使用成本更低的webAR，在简单的了解后选择了使用更广泛更轻量的AR.js。\n\n## AR.js\n\nAR.js是一个用于Web上增强现实的轻量级库，具有基于标记和基于位置的AR等功能。\nAR类型有三种\n\n- **图像跟踪**，当摄像机找到2D图像时，可以在其顶部或附近显示某种内容。内容也可以是2D图像，GIF，3D模型（也为动画）和2D视频。\n- **标记跟踪**，当摄像机找到标记时，可以显示一些内容（与图像跟踪相同）。标记非常稳定，但形状，颜色和大小受到限制。建议针对需要大量不同内容的标记的体验。\n    标记有三种类型 \n    - 宏（Hiro）\n    - 条码\n    - 图案\n- **基于位置的AR**，这种AR使用真实世界的位置来在用户设备上显示增强现实内容。\n  \nAR.js使用jsartoolkit5进行跟踪，渲染库使用的是three.js或A-Frame。\n\n## demo\n\ndemo使用的是图像跟踪的形式，将需要识别的图片通过`NFT Marker Creator`工具获取需要的识别文件。工具有两个版本，[web版](https://carnaux.github.io/NFT-Marker-Creator/#/)和[node.js](https://github.com/Carnaux/NFT-Marker-Creator)版本。需要处理的图片文件小数量少的话推荐使用web版的。特别注意的一点是图片dpi越高对后面识别的成功率越高。通过工具获取三个文件的图像描述符后放入相对应的文件夹。\n\n这边方便起见，使用的是A-Frame，也可以使用three.js的方式\n\n```\n<script src=\"https://cdn.jsdelivr.net/gh/aframevr/aframe@1c2407b26c61958baa93967b5412487cd94b290b/dist/aframe-master.min.js\"></script>\n\n<style>\n  .arjs-loader {\n    height: 100%;\n    width: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    background-color: rgba(0, 0, 0, 0.8);\n    z-index: 9999;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n\n  .arjs-loader div {\n    text-align: center;\n    font-size: 1.25em;\n    color: white;\n  }\n</style>\n\n<!-- rawgithack development URL -->\n<script src=\"https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js\"></script>\n\n<body style=\"margin: 0px; overflow: hidden\">\n  <!-- minimal loader shown until image descriptors are loaded -->\n  <div class=\"arjs-loader\">\n    <div>Loading, please wait...</div>\n  </div>\n  <a-scene\n    vr-mode-ui=\"enabled: false;\"\n    renderer=\"logarithmicDepthBuffer: true;\"\n    embedded\n    arjs=\"trackingMethod: best; sourceType: webcam; debugUIEnabled: false;\"\n  >\n    <!-- use rawgithack to retrieve the correct url for nft marker (see 'pinball' below) -->\n    <a-nft type=\"nft\" url=\"./trex/trex-image/trex\" smooth=\"true\" smoothCount=\"10\" smoothTolerance=\"0.01\" smoothThreshold=\"5\">\n      <a-entity\n        gltf-model=\"https://arjs-cors-proxy.herokuapp.com/https://raw.githack.com/AR-js-org/AR.js/master/aframe/examples/image-tracking/nft/trex/scene.gltf\"\n        scale=\"5 5 5\"\n        position=\"50 150 -100\"\n      >\n      </a-entity>\n    </a-nft>\n    <a-entity camera></a-entity>\n  </a-scene>\n</body>\n```\n\n效果如下\n<!-- ![js引入效果](/images/202202/1.gif) -->\n<img src=\"/images/202202/1.gif\"  height=\"330\" width=\"495\">\n\n## 总结\n\n静态模型和动态模型呈现效果都还不错，但关键的问题是定位不太准确。镜头晃动或者换个角度，模型与定位图片的相对坐标变动太大。原因浏览器的算力确实还不足以与客户端去媲美，图片的图像识别与追踪无法像基于标记类型的那样准确。由于基于移动端的浏览器进行测试配置。可能没办法在","tags":["AR"],"categories":["frontend"]},{"title":"A3工作法","url":"/2020/07/16/A3/","content":"\n## A3思考法\n\n原本为丰田公司的A3报告书，其实通过模板式的方法，解决问题\n\n## 1.主题\n\n一句话简单明了的设定目标。主题+做什么，例如：XX项目项目移交。\n\n## 2.主题设定的背景\n\n把握主题的目标、必要性等背景或理由。\n\n## 3.把握现状\n\n调查现状和问题，共享出来\n\n## 4.目标的设定\n\n5W2H方法制定计划，分配任务，从目标反向制定计划\n\n## 5.要因解析\n\n    丰田五问\n通过5个为什么来追究目标的本质，并进行解析\n\n## 6.对策和实施\n\n实施内容，边对上司进行中间报告，边实施内容\n\n## 7.实施的结果和横向展开\n\n对比实施前的预计后实施后的效果，好的方式标准化，横向展开到其他部门，落实日常工作中。卷入能力\n\n## 8.反省和今后的课题\n\n对问题进行反省，开展新课题作为今后的课题。\n","categories":["other"]},{"title":"配置数据大屏看板全屏","url":"/2020/07/16/big-screen-config/","content":"\n## 1.设置屏幕合并\n查看是否处于合屏状态\n打开NVIDIA控制面板\n可以在桌面上点击鼠标右键显示的菜单中打开NVIDIA控制面板\n图片: https://uploader.shimo.im/f/AwlY6WeYSTIQS7Mc.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTIzNDU1MDIsImZpbGVHVUlEIjoiOE5rNk0yTVJhTmNnOGFxTCIsImlhdCI6MTY1MjM0NTIwMiwidXNlcklkIjo0MDczMTkyMX0.dLRAVLnUG4wrXylBmlfT1Ud8XNdv26oRr466tAkeCKE\n点击左侧菜单中“设置多个显示器”\n如果显示两块屏幕则需要合并屏幕，如果显示一块可以进入访问看板的步骤\n图片: https://uploader.shimo.im/f/nyXfCWoM1UuRcwKb.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTIzNDU1MDIsImZpbGVHVUlEIjoiOE5rNk0yTVJhTmNnOGFxTCIsImlhdCI6MTY1MjM0NTIwMiwidXNlcklkIjo0MDczMTkyMX0.dLRAVLnUG4wrXylBmlfT1Ud8XNdv26oRr466tAkeCKE\n合并执行步骤\n1.点击左侧菜单中的“配置Surround、PhysX”\n图片: https://uploader.shimo.im/f/k9Phr2aWqOKcxrqg.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTIzNDU1MDIsImZpbGVHVUlEIjoiOE5rNk0yTVJhTmNnOGFxTCIsImlhdCI6MTY1MjM0NTIwMiwidXNlcklkIjo0MDczMTkyMX0.dLRAVLnUG4wrXylBmlfT1Ud8XNdv26oRr466tAkeCKE\n进入后进行设置，分辨率实际应为7680×2160\n\n图片: https://uploader.shimo.im/f/f3W4JUsnF356ug5l.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTIzNDU1MDIsImZpbGVHVUlEIjoiOE5rNk0yTVJhTmNnOGFxTCIsImlhdCI6MTY1MjM0NTIwMiwidXNlcklkIjo0MDczMTkyMX0.dLRAVLnUG4wrXylBmlfT1Ud8XNdv26oRr466tAkeCKE\n点击“启用Surround”进行确认，查看效果\n点击左侧菜单“设置多个显示器”，显示合成一块屏幕则设置成功。\n图片: https://uploader.shimo.im/f/mHy0Ciy5JbYlorAB.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTIzNDU1MDIsImZpbGVHVUlEIjoiOE5rNk0yTVJhTmNnOGFxTCIsImlhdCI6MTY1MjM0NTIwMiwidXNlcklkIjo0MDczMTkyMX0.dLRAVLnUG4wrXylBmlfT1Ud8XNdv26oRr466tAkeCKE\n\n## 2.访问看板\n打开浏览器，打开大看板的地址，\n将浏览器移到两块屏幕中间，按“F11”按键进入全屏，\n再按“F5”刷新更新看板样式\n\n问题QA\nQ:浏览器按F11只在其中一块屏幕中全屏\nA:需要先将浏览器移到两块屏幕中间，再按F11才能全屏在两块屏幕中\n","categories":["other"]}]